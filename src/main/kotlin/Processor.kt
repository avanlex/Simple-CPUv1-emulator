import java.nio.ByteBuffer
import kotlin.experimental.and

class Processor(simpleSystem: SimpleSystem) {

    var pc : Byte = 0
    var acc : Byte = 0

    var muxa : Boolean = false   // Output, ALU A input MUX control
    var muxb : Boolean = false   // ALU B input MUX control
    var muxc : Boolean = false   // Address MUX control, selecting PC or IR
    var en_da : Boolean = false  // Accumulator (ACC) register update control
    var en_pc : Boolean = false  // Program counter (PC) register update control
    var en_ir : Boolean = false  // Instruction register (IR) update control
    var ram_we : Boolean = false // Memory write enable control
    var alu_s0 : Boolean = false // ALU control line
    var alu_s1 : Boolean = false // ALU control line
    var alu_s2 : Boolean = false // ALU control line
    var alu_s3 : Boolean = false // ALU control line
    var alu_s4 : Boolean = false // ALU control line
    var alu_s  : Byte = 0        // ALU control Bus
    var ir : Short = 0           // Bus, 8bits, high byte of instruction register, contains opcode
    var zero : Boolean = false   // Driven by 8bit NOR gate connected to ALU output, if 1 indicates result is zero
    var carry : Boolean = false  // Driven by carry out (Cout) of ALU
    var clk : Boolean = false    // System clock
    var ce : Boolean = false     // Clock enable, normally set to 1, if set to 0 processor will HALT
    var clr : Boolean = false    // System reset, if pulsed high system will be reset

    //how many instructions and cycles have run
    var instructionCount: Long = 0
    var cycleCount: Long = 0

    //print out processor state for debugging?
    var doprint = false

    var system : SimpleSystem = simpleSystem

    fun mux4_1(a: Byte, b: Byte, c: Byte, d: Byte, sel: Byte): Byte {
        return when (sel){
            0b00.toByte() -> a
            0b01.toByte() -> b
            0b10.toByte() -> c
            else -> 0xFF.toByte()
        }
    }

    //called from main loop to run a single instruction
    fun doAnInstruction() {
        // fetch instruction word to
        ir = fetch()
        //read the opcode and get the registers and memory values
        decode()
        //figure out which instruction it is and do the computation and writeback
        execute()
        //update the cycle count
        //snes.nes.docycles(cycledelay()) //6 cyc per inst, sub 1 because inst includes the fetch
        instructionCount++
        if (doprint) printState()
    }

    private fun printState() {
        //TODO("Not yet implemented")
    }

    private fun execute() {
        //TODO("Not yet implemented")
    }

    //these values are generated by decode and used in execute
    var addr = 0
    var value = 0
    var value2 = 0
    var opcode : Byte = 0
    var opcodeName: String? = null
    var operandName:String? = null

    fun fetchInstruction() : Short{
        val value: Short = system.ram[pc.toInt()].toShort()
        pc = (pc + 1 and 0xff).toByte()
        return value
    }

    fun fetch() : Short{
        val value: Short = system.ram[pc.toInt()].toShort()
        pc = (pc + 1 and 0xff).toByte()
        return value
    }

    fun increment(){
        TODO("Not yet implemented")
    }

//    private fun fetch() : Byte {
//        val value: Byte = system.readByte((PC and 0xff).toByte())
//        PC = (PC + 1 and 0xffff).toShort()
//        return value
//    }



    /*
        FETCH
        DECODE
        EXECUTE
        INCREMENT
     */
    private fun decode() {

        val byteBuf: ByteBuffer = ByteBuffer.allocate(2)
        byteBuf.putShort(ir)
        opcode = byteBuf[0]
        val data = byteBuf[1]
        val opString = String.format("%8s", Integer.toBinaryString(opcode.toInt() and 0xFF)).replace(' ', '0')
        val dataString = String.format("%8s", Integer.toBinaryString(data.toInt() and 0xFF)).replace(' ', '0')

        val DEBUG = false

        if (DEBUG) {
            when (opcode) {
                Instruction.LOAD.opcode,
                Instruction.ADD.opcode,
                Instruction.AND.opcode,
                Instruction.SUB.opcode,
                Instruction.INPUT.opcode,
                Instruction.OUTPUT.opcode,
                Instruction.JUMPU.opcode,
                Instruction.JUMPZ.opcode,
                Instruction.JUMPC.opcode,
                Instruction.JUMPNZ.opcode,
                Instruction.JUMPNC.opcode -> println(
                    String.format(
                        "%6s",
                        Instruction.getName(opcode)
                    ) + " " + opString + " " + dataString
                )
                else -> throw Exception("Exception: INSTRUCTION NOT FOUND ($opString - $dataString)")
            }
        }

        /*
        Load ACC kk : ACC <- KK
        Add ACC kk : ACC <- ACC + KK
        And ACC kk : ACC <- ACC & KK
        Sub ACC kk : ACC <- ACC - KK
        Input ACC pp : ACC <- M[PP]
        Output ACC pp : M[PP] <- ACC
        Jump U aa : PC <- AA
        Jump Z aa : IF Z=1 PC <- AA ELSE PC <- PC + 1
        Jump C aa : IF C=1 PC <- AA ELSE PC <- PC + 1
        Jump NZ aa : IF Z=0 PC <- AA ELSE PC <- PC + 1
        Jump NC aa : IF C=0 PC <- AA ELSE PC <- PC + 1
        */

        //Instruction_Decoder
        when(opcode){
            Instruction.LOAD.opcode -> {
                acc = data
            }
            Instruction.ADD.opcode -> {
                alu_s = 0b00000
                acc = alu_v2(acc, data)
            }
            Instruction.AND.opcode -> {
                alu_s = 0b00001
                acc = alu_v2(acc, data)
            }
            Instruction.SUB.opcode -> {
                alu_s = 0b01100
                acc = alu_v2(acc, data)
            }
            Instruction.INPUT.opcode -> {
                alu_s = 0b00010 // INPUT A
                alu_s = 0b00011 // INPUT B
                alu_s = 0b10000 // INPUT A
                acc = alu_v2(acc, data)
            }
            Instruction.OUTPUT.opcode -> {
                alu_s = 0b00010 // OUTPUT A
//                acc = alu_v2(acc, data)
            }
            Instruction.JUMPU.opcode -> {
            }
            Instruction.JUMPZ.opcode -> {
            }
            Instruction.JUMPC.opcode -> {
            }
            Instruction.JUMPNZ.opcode -> {
            }
            Instruction.JUMPNC.opcode -> {
            }
            else -> {
                fault("ERROR INSTRUCTION NOT FOUND ($opString - $dataString)")
                throw Exception("EXCEPTION: INSTRUCTION NOT FOUND ($opString - $dataString)")
            }
        }

    }

    /*
      S4 S3 S2 S1 S0  Z
      0  0  0  0  0   ADD (A+B)
      0  0  0  0  1   BITWISE AND (A&B)
      0  0  0  1  0   INPUT A
      0  0  0  1  1   INPUT B
      0  1  1  0  0   SUBTRACT (A-B)
      1  0  1  0  0   INCREMENT (A+1)
      1  0  0  0  0   INPUT A
      0  0  1  0  0   ADD (A+B)+1
      0  1  0  0  0   SUBTRACT (A-B)-1
     */
    fun alu_v2(a: Byte, b: Byte, s0: Boolean, s1: Boolean, s2: Boolean, s3: Boolean, s4: Boolean): Byte {
        var alu_data = 0.toByte()
        var bits = 0
        if (s0) {bits = bits or (1 shl 0)}
        if (s1) {bits = bits or (1 shl 1)}
        if (s2) {bits = bits or (1 shl 2)}
        if (s3) {bits = bits or (1 shl 3)}
        if (s4) {bits = bits or (1 shl 4)}
        when (bits and 0x1F){
            0b00000 -> {alu_data = (a + b).toByte()} // ADD (A+B)
            0b00001 -> {alu_data = a and b} // BITWISE AND (A&B)
            0b00010 -> {alu_data = a } // INPUT A
            0b00011 -> {alu_data = b } // INPUT B
            0b01100 -> {alu_data = (a.toByte() - b.toByte()).toByte() // SUBTRACT (A-B)
            }
            0b10100 -> {alu_data = (a.toByte() + 1.toByte()).toByte() // INCREMENT (A+1)
            }
            0b10000 -> {alu_data = a } // INPUT A
            0b00100 -> {
                alu_data = (a.toByte() + b.toByte() + 1.toByte()) // ADD (A+B)+1
                    .toByte()
            }
            0b01000 -> {
                alu_data = (a.toByte() - b.toByte() - 1.toByte()) // SUBTRACT (A-B)-1
                    .toByte()
            }
        }
        return alu_data
    }

    fun alu_v2(a: Byte, b: Byte): Byte {
        var alu_data = 0.toByte()
        var bits = alu_s.toInt() and 0x1F
        /*
        if (alu_s0) {bits = bits or (1 shl 0)}
        if (alu_s1) {bits = bits or (1 shl 1)}
        if (alu_s2) {bits = bits or (1 shl 2)}
        if (alu_s3) {bits = bits or (1 shl 3)}
        if (alu_s4) {bits = bits or (1 shl 4)}
        */
        when (bits and 0x1F){
            0b00000 -> {alu_data = (a + b).toByte()} // ADD (A+B)
            0b00001 -> {alu_data = a and b} // BITWISE AND (A&B)
            0b00010 -> {alu_data = a } // INPUT A
            0b00011 -> {alu_data = b } // INPUT B
            0b01100 -> {alu_data = (a.toByte() - b.toByte()).toByte() // SUBTRACT (A-B)
            }
            0b10100 -> {alu_data = (a.toByte() + 1.toByte()).toByte() // INCREMENT (A+1)
            }
            0b10000 -> {alu_data = a } // INPUT A
            0b00100 -> {
                alu_data = (a.toByte() + b.toByte() + 1.toByte()) // ADD (A+B)+1
                    .toByte()
            }
            0b01000 -> {
                alu_data = (a.toByte() - b.toByte() - 1.toByte()) // SUBTRACT (A-B)-1
                    .toByte()
            }
        }
        return alu_data
    }

    //an invalid instruction byte was encountered
    private fun fault(message: String) {
        println(message)
//		System.exit(0);
    }

}


